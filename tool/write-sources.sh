#!/bin/sh

# 定义内置配置
THIS_FILE_PATH=$(
  cd $(dirname $0)
  pwd
)
ARG_LIST=
PROJECT_PATH="../"
FILE_PATH="tool"
FILE_NAME="main"

# 定义内置函数
function ouput_debug_msg() {
  local debug_msg=$1
  local debug_swith=$2
  if [[ "$debug_swith" =~ "false" ]]; then
    echo $debug_msg >/dev/null 2>&1
  elif [ -n "$debug_swith" ]; then
    echo $debug_msg
  elif [[ "$debug_swith" =~ "true" ]]; then
    echo $debug_msg
  fi
}
function path_resolve_for_relative() {
  local str1="${1}"
  local str2="${2}"
  local slpit_char1=/
  local slpit_char2=/
  if [[ -n ${3} ]]; then
    slpit_char1=${3}
  fi
  if [[ -n ${4} ]]; then
    slpit_char2=${4}
  fi

  # 路径-转为数组
  local arr1=(${str1//$slpit_char1/ })
  local arr2=(${str2//$slpit_char2/ })

  # 路径-解析拼接
  #2 遍历某一数组
  #2 删除元素取值
  #2 获取数组长度
  #2 获取数组下标
  #2 数组元素赋值
  for val2 in ${arr2[@]}; do
    length=${#arr1[@]}
    if [ $val2 = ".." ]; then
      index=$(($length - 1))
      if [ $index -le 0 ]; then index=0; fi
      unset arr1[$index]
      #echo ${arr1[*]}
      #echo  $index
    else
      index=$length
      arr1[$index]=$val2
      #echo ${arr1[*]}
    fi
  done
  # 路径-转为字符
  local str3=''
  for i in ${arr1[@]}; do
    str3=$str3/$i
  done
  if [ -z $str3 ]; then str3="/"; fi
  echo $str3
}
function path_resolve() {
  local str1="${1}"
  local str2="${2}"
  local slpit_char1=/
  local slpit_char2=/
  if [[ -n ${3} ]]; then
    slpit_char1=${3}
  fi
  if [[ -n ${4} ]]; then
    slpit_char2=${4}
  fi

  #FIX:when passed asboult path,dose not return the asboult path itself
  #str2="/d/"
  local str3=""
  str2=$(echo $str2 | sed "s#/\$##")
  ABSOLUTE_PATH_REG_PATTERN="^/"
  if [[ $str2 =~ $ABSOLUTE_PATH_REG_PATTERN ]]; then
    str3=$str2
  else
    str3=$(path_resolve_for_relative $str1 $str2 $slpit_char1 $slpit_char2)
  fi
  echo $str3
}
function get_help_msg() {
  local USAGE_MSG=$1
  local USAGE_MSG_FILE=$2
  if [ -n $USAGE_MSG ]; then
    echo "$USAGE_MSG"
  elif [ -n $USAGE_MSG_FILE && -e $USAGE_MSG_FILE ]; then
    #cat $USAGE_MSG_FILE
    echo "has help file"
  else
    echo "no help msg and file"
  fi
}
function get_help_msg() {
  local USAGE_MSG=$1
  local USAGE_MSG_FILE=$2
  if [ -z $USAGE_MSG ]; then
    if [[ -n $USAGE_MSG_FILE && -e $USAGE_MSG_FILE ]]; then
      USAGE_MSG=$(cat $USAGE_MSG_FILE)
    else
      USAGE_MSG="no help msg and file"
    fi
  fi
  echo "$USAGE_MSG"
}
# 文档帮助信息
USAGE_MSG=$(
  cat <<EOF
desc:
  genarate basic sh file
args:
  --file-name optional,set the ouput file name
  --file-path optional,set the ouput file path
  --project-path optional,set the project path
  -d,--debug optional,set the debug mode
  -h,--help optional,get the cmd help
how-to-run:
  run as shell args
    bash ./write-sources.sh
  run as runable application
    ./write-sources.sh --file-name eth0
demo-with-args:
  without-args
    ok:./write-sources.sh
  passed arg with necessary value
    ok:./write-sources.sh --file-name eth0
    ok:./write-sources.sh --file-name=eth0
  passed arg with optional value
  passed arg without value
how-to-get-help:
  ok:./write-sources.sh --help
  ok:./write-sources.sh -h
  ok:./write-sources.sh --debug
EOF
)
USAGE_MSG=$(
  cat <<EOF
$USAGE_MSG

basic usage:
 set the file name
./generate.sh --file-name main

 set the file path
 case)set a relative path
./generate.sh --file-path ../src
 case)set a absoulte path
./generate.sh --file-path /

built-in config var:
FILE_NAME=
FILE_PATH=
EOF
)

# 参数规则内容
GETOPT_ARGS_SHORT_RULE="--options h,d"
GETOPT_ARGS_LONG_RULE="--long help,debug,file-name:,file-path:,project-path:"

# 设置参数规则
GETOPT_ARGS=$(
  getopt $GETOPT_ARGS_SHORT_RULE \
  $GETOPT_ARGS_LONG_RULE -- "$@"
)
# 解析参数规则
eval set -- "$GETOPT_ARGS"
while [ -n "$1" ]; do
  case $1 in
  --file-name)
    ARG_FILE_NAME=$2
    shift 2
    ;;
  --file-path)
    ARG_FILE_PATH=$2
    shift 2
    ;;
  --project-path)
    ARG_PROJECT_PATH=$2
    shift 2
    ;;
  -h | --help) #可选，不接参数
    echo "$USAGE_MSG"
    exit 1
    ;;
  -d | --debug) #可选，不接参数
    IS_DEBUG_MODE=true
    shift 2
    ;;
  --)
    break
    ;;
  *)
    echo "$USAGE_MSG"
    ;;
  esac
done
# 处理剩余参数

# 更新内置变量
if [ -n "$ARG_FILE_NAME" ]; then
  FILE_NAME=$ARG_FILE_NAME
fi
if [ -n "$ARG_PROJECT_PATH" ]; then
  PROJECT_PATH=$ARG_PROJECT_PATH
fi
if [ -n "$ARG_FILE_PATH" ]; then
  FILE_PATH=$ARG_FILE_PATH
fi

###
#输出配置信息
###
# below generated by write-sources.sh

# 脚本主要代码
# add multi line text to a var
PROJECT_PATH=$(path_resolve $THIS_FILE_PATH $PROJECT_PATH)
HELP_DIR=$PROJECT_PATH/help
SRC_DIR=$PROJECT_PATH/src
TEST_DIR=$PROJECT_PATH/test
DIST_DIR=$PROJECT_PATH/dist
DOCS_DIR=$PROJECT_PATH/docs
TOOL_DIR=$PROJECT_PATH/tool
FILE_PATH=$(path_resolve $PROJECT_PATH $FILE_PATH)
mkdir -p $FILE_PATH
OUTPUT_FILE=$FILE_PATH/$FILE_NAME.sh

ouput_debug_msg "生成输入文件 ..." "true"

function get_file_part() {
  local FLAG_SYMBOL=desc
  local FILE_SUFFIX=.help.tpl
  if [[ -n "$1" ]]; then
    FLAG_SYMBOL=$1
  fi
  if [[ -n "$2" ]]; then
    FILE_SUFFIX=$2
  fi
  # the begining flag of the section
  local BeginFlag="<$FLAG_SYMBOL>"
  # the ending flag of the section
  local EndFlag="<$FLAG_SYMBOL/>"

  local Bnum=
  local Enum=
  local nums=
  FILE=$SRC_DIR/${FILE_NAME}${FILE_SUFFIX} #$1
  # line number of the beginning flag
  Bnum=$(grep -n "$BeginFlag" $FILE | cut -d: -f1)
  # line number of the ending flag
  Enum=$(grep -n "$EndFlag" $FILE | cut -d: -f1)
  # lines between the begining and ending flag
  nums=$(($Enum - $Bnum))
  #echo $Bnum,$Enum,$nums
  # output the result into stdout
  PART_CONTENT=$(grep -A $nums "$BeginFlag" $FILE | sed "s#<$FLAG_SYMBOL>#$FLAG_SYMBOL:#" | sed "s#<$FLAG_SYMBOL/>##")
  echo "$PART_CONTENT"
}

# ./tool/debug.sh --file-name write-sources

declare -A DIC_CODE_LIST
DIC_CODE_LIST=()

CODE_LIST_DESC=
string=$(
  cat <<EOF
core_file_head
core_define_built_in_var
core_define_built_in_fun
core_include_commom_code
core_arg_help_msg
core_arg_rule_content
core_set_arg_rule
core_parse_arg_rule
core_handle_the_rest_arg
core_update_built_in_var
core_print_config_info
core_main_code
EOF
)
#echo $string
REG_SHELL_COMMOMENT_PATTERN="^#"
array=(${string//,/ })

CODE_LIST_DESC=
for var in ${array[@]}; do
  if [[ "$var" =~ $REG_SHELL_COMMOMENT_PATTERN ]]; then
    echo "$var" >/dev/null 2>&1
  else
    temp=$(get_file_part $var .sh.dist.tpl | sed "/^$var:*/d")
    CODE_LIST_DESC=$(
      cat <<EOF
$CODE_LIST_DESC
$temp
EOF
    )
    DIC_CODE_LIST+=([$var]=$temp)
  fi
done
#echo "$CODE_LIST_DESC"

ARG_LIST_DESC=$(get_file_part args .help.tpl | sed "/^args:*/d")
ARG_LIST_DESC=$(echo "$ARG_LIST_DESC" | sed "/^ *-d,--debug.*/d" | sed "/^ *-h,--help.*/d")
ARG_LIST=$(echo "$ARG_LIST_DESC" | sed "s/-.,//g" | sed "s/optional.*//g")
#echo "$ARG_LIST_DESC"
#echo "$ARG_LIST"

ARG_SHORT_LONG_MAP=$(echo "$ARG_LIST_DESC" | sed "s/optional.*//g" | sed "s/ *//g" | sed "s/,/=/g")
#echo "$ARG_SHORT_LONG_MAP"

declare -A DIC_ARG_SHORT_LONG_MAP
DIC_ARG_SHORT_LONG_MAP=()
test=$(echo $ARG_SHORT_LONG_MAP)
#echo $test
slpit_char=" "
#字符转为数组
arr=(${test//$slpit_char/ })
key=
value=
for i in "${arr[@]}"; do

  # 获取键值：小写+中划
  value=$(echo $i | cut -d "=" -f 1 | tr "[:upper:]" "[:lower:]" | sed "s/-//g")
  # 获取键名:小写
  key=$(echo $i | cut -d "=" -f 2 | tr "[:upper:]" "[:lower:]" | sed "s/--//g")
  #echo $key,$value
  length=${#value}
  if [ $length -gt 1 ]; then
    echo "not short arg" >/dev/null 2>&1
  else
    DIC_ARG_SHORT_LONG_MAP+=([$key]=$value)
  fi
done
#echo "${DIC_ARG_SHORT_LONG_MAP['sdate']}"

ouput_debug_msg "读取输入文件 ..." "true"
declare -A dic
#设置二维数组
dic=()
test=$(echo "$ARG_LIST")
#字符转为数组
arr=($test)
key=
value=
for i in "${arr[@]}"; do
  # 获取键名:小写+中划
  key=$(echo $i | tr "[:upper:]" "[:lower:]" | sed "s/--//g")
  # 获取键值：大写+下划+前缀
  value=$(echo $i | tr "[:lower:]" "[:upper:]" | sed "s/--/ARG_/g" | sed "s/-/_/g")
  dic+=([$key]=$value)
done

ouput_debug_msg "参数规则内容" "true"
ARGS_RULE_SHORT_TXT=
for i in $(echo ${DIC_ARG_SHORT_LONG_MAP[*]}); do
  # 小写
  key=$(echo $i | tr "[:upper:]" "[:lower:]")
  ARGS_RULE_SHORT_TXT="${ARGS_RULE_SHORT_TXT}${key}:,"
done
ARGS_RULE_SHORT_TXT=$(echo $ARGS_RULE_SHORT_TXT | sed "s/,$//g")

ARGS_RULE_TXT=""
for i in $(echo ${!dic[*]}); do
  # 小写+中划
  key=$(echo $i | tr "[:upper:]" "[:lower:]" | sed "s/--//g")
  ARGS_RULE_TXT="${ARGS_RULE_TXT}${key}:,"
done
ARGS_RULE_TXT=$(echo $ARGS_RULE_TXT | sed "s/,$//g")
ARGS_RULE_TXT=$(echo "${DIC_CODE_LIST["core_arg_rule_content"]}" | sed "s/\$ARGS_RULE_SHORT_TXT/$ARGS_RULE_SHORT_TXT/g" | sed "s/\$ARGS_RULE_TXT/$ARGS_RULE_TXT/g")
#swap_var="${DIC_CODE_LIST["core_arg_rule_content"]}"
DIC_CODE_LIST["core_arg_rule_content"]="$ARGS_RULE_TXT"
#echo "${DIC_CODE_LIST["core_arg_rule_content"]}"
#exit 1

ouput_debug_msg "设置参数规则" "true"
#echo "${DIC_CODE_LIST["core_set_arg_rule"]}"
#exit 1

ouput_debug_msg "解析参数规则" "true"
PARSE_ARGS_TXT=$(
  cat <<ARG-LIST-EOF
while [ -n "\$1" ]
do
    case \$1 in
ARG-LIST-EOF
)
#echo "$PARSE_ARGS_TXT"

for i in $(echo ${!dic[*]}); do
  # 小写+中划
  key="$i"
  # 大写+下划+前缀
  val=${dic[$i]}
  short_val=${DIC_ARG_SHORT_LONG_MAP[$key]}
  if [ -n "$short_val" ]; then

    key="-$short_val|--$key"
  else
    key="--$key"
  fi
  #echo $key
  PARSE_ARGS_TXT=$(
    cat <<ARG-LIST-EOF
$PARSE_ARGS_TXT
    $key)
    $val=\$2
    shift 2
    ;;
ARG-LIST-EOF
  )
done

PARSE_ARGS_TXT=$(
  cat <<ARG-LIST-EOF
$PARSE_ARGS_TXT
    -h|--help)
    echo "\$USAGE_MSG"
    exit 1
    ;;
    -d|--debug)
    IS_DEBUG_MODE=true
    shift 2
    ;;
    --)
    break
    ;;
    *)
    printf "\$USAGE_MSG"
    ;;
    esac
done
ARG-LIST-EOF
)

swap_var="${DIC_CODE_LIST["core_parse_arg_rule"]}"
PARSE_ARGS_TXT=$(
  cat <<EOF
$swap_var
$PARSE_ARGS_TXT
EOF
)
DIC_CODE_LIST["core_parse_arg_rule"]="$PARSE_ARGS_TXT"
#echo "${DIC_CODE_LIST["core_parse_arg_rule"]}"
#exit 1

ouput_debug_msg "处理其余参数" "true"
#echo "${DIC_CODE_LIST["core_handle_the_rest_arg"]}"
#exit 1

ouput_debug_msg "更新内置变量" "true"
for i in $(echo ${!dic[*]}); do
  # 大写+下滑
  key=$(echo $i | tr "[:lower:]" "[:upper:]" | sed "s/-/_/g")
  # 大写+下划+前缀
  val=${dic[$i]}
  UPDATE_BUILT_IN_CONFIG_TXT=$(
    cat <<UPDATE-BUILT-IN-CONFIG
$UPDATE_BUILT_IN_CONFIG_TXT
if [ -n "\$$val" ]
then
    $key=\$$val
fi
UPDATE-BUILT-IN-CONFIG
  )
done

swap_var="${DIC_CODE_LIST["core_update_built_in_var"]}"
DIC_CODE_LIST["core_update_built_in_var"]=$(
  cat <<EOF
$swap_var
$UPDATE_BUILT_IN_CONFIG_TXT
EOF
)
#echo "${DIC_CODE_LIST["core_update_built_in_var"]}"
#echo "${DIC_CODE_LIST[@]}"
#exit 1

ouput_debug_msg "输出配置信息" "true"
BUIT_IN_VAR_TXT=
for i in $(echo ${!dic[*]}); do
  # 大写+下滑
  key=$(echo $i | tr "[:lower:]" "[:upper:]" | sed "s/-/_/g")
  BUIT_IN_VAR_TXT="${BUIT_IN_VAR_TXT},${key}"
done
BUIT_IN_VAR_TXT=$(echo $BUIT_IN_VAR_TXT | sed "s/,/,$/g" | sed "s/^,//g")
BUIT_IN_VAR_TXT=$(
  cat <<EOF
${DIC_CODE_LIST["core_print_config_info"]}
echo $BUIT_IN_VAR_TXT
EOF
)
DIC_CODE_LIST["core_print_config_info"]="$BUIT_IN_VAR_TXT"
#echo "${DIC_CODE_LIST["core_print_config_info"]}"
#exit 1

ouput_debug_msg "脚本主要代码" "true"
#echo "${DIC_CODE_LIST["core_main_code"]}"
#exit 1

MY_CODE=
for var in ${array[@]}; do
  if [[ "$var" =~ $REG_SHELL_COMMOMENT_PATTERN ]]; then
    echo "$var" >/dev/null 2>&1
  else
    #echo "$var"
    #echo "${DIC_CODE_LIST[$var]}"
    MY_CODE=$(
      cat <<EOF
$MY_CODE
${DIC_CODE_LIST[$var]}
EOF
    )
  fi
done

#echo "$MY_CODE" >$OUTPUT_FILE
echo "write codes to $OUTPUT_FILE"
echo "$MY_CODE" >$OUTPUT_FILE

# usage
# ./tool/write-sources.sh --help
# ./tool/write-sources.sh
# ./tool/debug.sh --file-name write-sources --file-path debug
# ./debug/write-sources.sh --help
